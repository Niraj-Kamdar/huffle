/* Interface */
#define function requestRandom() nonpayable returns (uint256)
#define function rawFulfillRandomWords(uint256 reqId, uint256[] calldata words) nonpayable returns ()
#define function getLastRequestId() view returns (bytes32)
#define function getRandomNumber(bytes32) view returns (uint256)

/* Events */
#define event VRFRequested(bytes32 indexed requestId)

/* constants */
#define constant COORDINATOR = 0x9DdfaCa8183c41ad55329BdeeD9F6A8d53168B1B
#define constant KEY_HASH = 0x787d74caea10b2b357790d5b5247c2f63d1d91572a9846f780606e4d953677ae
#define constant SUB_ID = 0xcf92af81122d318b5046c261b0f3dec930e34ca12918d554f577cff6fcb5a18a
#define constant REQUEST_CONFIRMATIONS = 0x03
#define constant CALLBACK_GAS_LIMIT = 0x186a0
#define constant RANDOM_NUM_WORDS = 0x01

// selector: requestRandomWords((bytes32,uint256,uint16,uint32,uint32,bytes))
#define constant REQUEST_RANDOM_WORDS_SELECTOR = 0x9b1c385e
// selector: EXTRA_ARGS_V1_TAG (0x92fd1338)
#define constant EXTRA_BYTES_SELECTOR = 0x92fd1338

/* storage slots */
#define constant LAST_REQUEST_ID = FREE_STORAGE_POINTER()

// Why we encode like this? it's because solidity expect it like that.
// If it's upto huff we would be packing more efficiently
#define macro REQUEST_RANDOM() = takes (0) returns (0) {
    [REQUEST_RANDOM_WORDS_SELECTOR] 0xe0 shl // [REQUEST_RANDOM_WORDS_SELECTOR]
    0x0                             // [0x0, REQUEST_RANDOM_WORDS_SELECTOR]
    mstore                          // []

    0x20   // [0x20] offset
    0x04   // [0x04, 0x20] ptr to offset in memory
    mstore // []

    [KEY_HASH] // [KEY_HASH]
    0x24       // [0x24, KEY_HASH]
    mstore // []

    [SUB_ID] // [SUB_ID]
    0x44       // [0x44, SUB_ID]
    mstore // []

    [REQUEST_CONFIRMATIONS] // [KEY_HASH]
    0x64       // [0x64, KEY_HASH]
    mstore // []

    [CALLBACK_GAS_LIMIT] // [CALLBACK_GAS_LIMIT]
    0x84       // [0x64, CALLBACK_GAS_LIMIT]
    mstore // []

    [RANDOM_NUM_WORDS] // [RANDOM_NUM_WORDS]
    0xa4       // [0xa4, RANDOM_NUM_WORDS] remember hex
    mstore // []

    0xc0 // offset to extra bytes (5 fields from start of tuple and 6th offset hence 6*32 = 0xc0)
    0xc4
    mstore

    0x24  // 4 selctor bytes + 32 bytes bool = 36 = 0x24
    0xe4  //
    mstore

    [EXTRA_BYTES_SELECTOR] 0xe0 shl // extra bytes data followed by bool false
    0x104
    mstore

    0x00 // explicitly marking 0s (not really required if you don't write anything here)
    0x124
    mstore

    HANDLE_COORDINATOR_CALL()
}

#define macro HANDLE_COORDINATOR_CALL() = takes (0) returns (0) {
    // 1. Prepare stack for call(g, a, v, in, insize, out, outsize)
    0x20                // [retSize]
    0x00                // [retOffset] (return data ptr in memory)
    0x144               // [argsSize]
    0x00                // [argsOffset] (args ptr in memory)
    0x00                // [value]
    [COORDINATOR]       // [address]
    gas                 // [gas]

    //Stack so far: [gas, address, value, argsOffset, argsSize, retOffset, retSize]
    // 2. Execute call
    call                // [success]

    // 'success' is now on top of the stack (0 for failure, 1 for success)
    // TODO: use iszero and single jump
    iszero failure jumpi

    0x20 0x00
    __EVENT_HASH(VRFRequested)
    log1

    stop

    failure:
        0x0 0x0 revert // [offset, size]
}

#define macro FULFILL_RANDOM_WORDS() = takes(0) returns (0) {
    caller
    [COORDINATOR]
    eq
    iszero error jumpi

    // selector (0x04) + reqId (0x20) + array offset(0x20) + array length (0x20) + array data (0x20) (one word)

    // Load value first
    0x64 calldataload // Note: unlike solidity we already know calldata layout and selectively load needed data

    0x4 calldataload // [reqId]
    dup1
    [LAST_REQUEST_ID]
    sstore

    // Stack: [[LAST_REQUEST_ID], random_word]
    // Note: LAST_REQUEST_ID is keccak256 and collision chance are astronomically low so this would be safe
    // Think carefully before doing this Ex: two different mapping with same key causes collision
    sstore
    stop

    error:
        0x0 0x0 revert // TODO: add custom error
}

#define macro GET_LAST_REQUEST_ID() = takes (0) returns (0) {
    [LAST_REQUEST_ID]
    sload
    0x00 mstore
    0x20 0x00 return
}

#define macro GET_RANDOM_NUMBER() = takes (0) returns (0) {
    0x04 calldataload
    sload
    0x00 mstore
    0x20 0x00 return
}


#define macro MAIN() = takes (0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr
    dup1 __FUNC_SIG(requestRandom) eq request jumpi
    dup1 __FUNC_SIG(rawFulfillRandomWords) eq fulfill jumpi
    dup1 __FUNC_SIG(getLastRequestId) eq getLastRequestId jumpi
    __FUNC_SIG(getRandomNumber) eq getRandomNumber jumpi

    0x00 0x00 revert

    request:
        REQUEST_RANDOM()
    fulfill:
        FULFILL_RANDOM_WORDS()
    getLastRequestId:
        GET_LAST_REQUEST_ID()
    getRandomNumber:
        GET_RANDOM_NUMBER()
}
